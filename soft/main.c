/*---------------------------------------------------------------*/
/* Automotive GPS logger                       (C)ChaN, 2014     */
/*---------------------------------------------------------------*/

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/sleep.h>
#include <string.h>
#include "ff.h"
#include "diskio.h"
#include "uart.h"
#include "suart.h"
#include "xitoa.h"
#include "stime.h"


FUSES = {0xE6, 0xD9, 0xFD};		/* ATmega328P fuses: Low, High, Extended.
This is the fuse settings for this project. The fuse bits will be included
in the output hex file with program code. However some old flash programmers
cannot load the fuse bits from hex file. If it is the case, remove this line
and use these values to program the fuse bits. */


#define LOCALDIFF	+9			/* Time difference from UTC [hours] */
#define	IVT_SYNC	180			/* f_sync() interval (0:no periodic sync) [sec] */

#define	VI_LVL		9.0			/* Blackout threshold [volt] */
#define	VI_LVH		10.0		/* Recharge threshold [volt] */
#define	VI_MULT		(10.0 / 130 / 3.0 * 1024)

#define	BEEP_ON()		TCCR0A = 0b01000010
#define	BEEP_OFF()		TCCR0A = 0b10000010
#define	LEDG_ON()		PORTB &= ~_BV(0)
#define	LEDG_OFF()		PORTB |= _BV(0)
#define GPS_ON()		PORTC |= _BV(1)
#define GPS_OFF()		PORTC &= ~_BV(1)

#define	DELAY_MS(d)		{for (Timer = (BYTE)(d / 10); Timer; ) ; }



FATFS Fatfs;				/* File system object for each logical drive */
FIL File1;					/* File object */
char Line[100];				/* Line buffer */

volatile BYTE Timer;		/* 100Hz decrement timer */

#define FLAGS	GPIOR0		/* Status flags and bit definitions */
#define	F_POW	0x80		/* Power */
#define	F_GPSOK	0x08		/* GPS data valid */
#define	F_SYNC	0x04		/* Sync request */
#define	F_LVD	0x01		/* Low battery detect */



/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC1A                 */
/*---------------------------------------------------------*/

ISR(TIMER1_COMPA_vect)
{
	BYTE n;
	WORD ad;
	static WORD ivt_sync;
	static BYTE led, lvt;


	n = Timer;
	if (n) Timer = --n;;

	/* Sync interval */
	if (IVT_SYNC && ++ivt_sync >= IVT_SYNC * 100) {
		ivt_sync = 0;
		FLAGS |= F_SYNC;
	}

	/* Green LED drive */
	if (FLAGS & F_POW) {
		if ((FLAGS & F_GPSOK) || (++led & 0x20)) {
			LEDG_ON();
		} else {
			LEDG_OFF();
		}
	} else {
		LEDG_OFF();
	}

	/* Power supply monitor */
	ad = ADC * 100;
	ADMUX = 7;
	ADCSRA = _BV(ADEN)|_BV(ADSC)|0b110;
	if (FLAGS & F_LVD) {
		if (ad > (WORD)(VI_LVH * VI_MULT) * 100) {
			FLAGS &= ~F_LVD;
			lvt = 0;
		}
	} else {
		if (ad < (WORD)(VI_LVL * VI_MULT) * 100) {
			if (++lvt >= 10)
				FLAGS |= F_LVD;
		} else {
			lvt = 0;
		}
	}

	/* MMC/SD timer procedure */
	disk_timerproc();
}




/*---------------------------------------------------------*/
/* User Provided Timer Function for FatFs module           */
/*---------------------------------------------------------*/

DWORD get_fattime (void)
{
	return 0;
}



/*----------------------------------------------------*/
/*  Get a line received from GPS module               */
/*----------------------------------------------------*/

UINT get_line (		/* 0:Brownout, >0: Number of bytes received. */
	char *buff,
	UINT sz_buf
)
{
	char c;
	UINT i = 0;


	for (;;) {
		if (FLAGS & F_LVD) return 0;	/* A brownout is detected */
		if (!uart_test()) continue;
		c = (char)uart_get();
		xputc(c);
		if (i == 0 && c != '$') continue;	/* Find start of line */
		buff[i++] = c;
		if (c == '\n') break;	/* EOL */
		if (i >= sz_buf) i = 0;	/* Buffer overflow (abort this line) */
	}

	return i;
}



/*--------------------------------------------------------------------------*/
/* Controls                                                                 */

void beep (UINT len, BYTE cnt)
{
	while (cnt--) {
		BEEP_ON();
		DELAY_MS(len);
		BEEP_OFF();
		DELAY_MS(len);
	}
}



/* Compare sentence header string */
BYTE gp_comp (const char *str1, const prog_char *str2)
{
	char c;

	do {
		c = pgm_read_byte(str2++);
	} while (c && c == *str1++);
	return c;
}



/* Get a column item */
static
BYTE* gp_col (			/* Returns pointer to the item (returns a NULL when not found) */
	const char* buf,	/* Pointer to the sentence */
	BYTE col			/* Column number (0 is the 1st item) */
) {
	BYTE c;


	while (col) {
		do {
			c = *buf++;
			if (c <= ' ') return NULL;
		} while (c != ',');
		col--;
	}
	return (BYTE*)buf;
}




static
BYTE gp_val2 (
	const BYTE *db
)
{
	BYTE n, m;


	n = db[0] - '0';
	if (n >= 10) return 0;
	m = db[1] - '0';
	if (m >= 10) return 0;

	return n * 10 + m;
}




static
time_t gp_rmctime (	/* Get GPS status from RMC sentence */
	const char *str
)
{
	const BYTE *p;
	struct tm tmc;
	time_t utc;


	if (gp_comp(str, PSTR("$GPRMC"))) return 0;	/* Not the RMC */

	p = gp_col(str, 2);		/* Get status */
	if (!p || *p != 'A') {
		FLAGS &= ~F_GPSOK;
		return 0;
	}

	p = gp_col(str, 1);		/* Get h:m:s */
	if (!p) return 0;
	tmc.tm_hour = gp_val2(p);
	tmc.tm_min = gp_val2(p+2);
	tmc.tm_sec = gp_val2(p+4);

	p = gp_col(str, 9);		/* Get y:m:d */
	if (!p) return 0;
	tmc.tm_mday = gp_val2(p);
	tmc.tm_mon = gp_val2(p+2) - 1;
	tmc.tm_year = gp_val2(p+4) + 100;

	utc = mktime(&tmc);				/* Check time validity */
	if (utc == -1) return 0;

	FLAGS |= F_GPSOK;
	return utc;
}




static
void ioinit (void)
{
	PORTB = 0b00000011;	 	/* --zzzzHH */
	DDRB  = 0b00000011;

	PORTC = 0b00111101;		/* --uuuuLH */
	DDRC  = 0b00000011;

	PORTD = 0b10111110;		/* uLuuuuHz */
	DDRD  = 0b01000010;

	OCR1A = F_CPU/8/100-1;		/* Timer1: 100Hz interval (OC1A) */
	TCCR1B = 0b00001010;
	TIMSK1 = _BV(OCIE1A);		/* Enable TC1.oca interrupt */

	OCR0A = F_CPU/64/4000/2-1;	/* Timer0: 4kHz sound (OC0A) */
	TCCR0A = 0b10000010;
	TCCR0B = 0b00000011;

	ACSR = _BV(ACD);		/* Disable analog comp */

	sei();
}



/*-----------------------------------------------------------------------*/
/* Main                                                                  */
/*-----------------------------------------------------------------------*/

int main (void)
{
	UINT bw, len, err;
	struct tm *ct;
	time_t utc;
	FRESULT res;


	ioinit();
#ifdef LEDR_UART
	xdev_out(xmit);
#endif

	err = 0;
	for (;;) {
		beep(250, err);	/* Error beep */
		err = 0;

		/* Wait for supply voltage stabled */
		while (FLAGS & F_LVD) ;
		DELAY_MS(500);
		if (FLAGS & F_LVD) continue;
		if (disk_status(0) & STA_NODISK) continue;

		res = f_mount(&Fatfs, "", 1);
		if (res != FR_OK) {
			xprintf(PSTR("FS error %u\r\n"), res);
			err = 2; continue;
		}
		xputs(PSTR("FS Ok\r\n"));
		beep(50, 1);				/* 1 beep */

		/* Initialize GPS receiver */
		GPS_ON();		/* GPS power on */
		FLAGS |= F_POW;
		DELAY_MS(300);	/* Delay */
		uart_init();	/* Enable UART */
		xfprintf(uart_put, PSTR("$PSRF106,21*0F\r\n"));	/* Send initialization command (depends on the receiver) */

		utc = 0;
		for (;;) {
			len = get_line(Line, sizeof Line);	/* Receive a line from GPS receiver */
			if (!len) break;		/* Brownout? */

			if (!utc) {
				utc = gp_rmctime(Line);	/* Get time in UTC from a valid RMC sentence */
				if (utc) {
					utc += LOCALDIFF * 3600L;	/* Local time */
					ct = gmtime(&utc);
					xsprintf(Line, PSTR("%02u%02u%02u.LOG"), ct->tm_year % 100, ct->tm_mon + 1, ct->tm_mday);
					xprintf(PSTR("Open %s\r\n"), Line);
					if (f_open(&File1, Line, FA_WRITE | FA_OPEN_ALWAYS)		/* Open log file */
						|| f_lseek(&File1, f_size(&File1)) 					/* Append mode */
						|| f_write(&File1, "\r\n", 2, &bw))					/* Put a blank line as start marker */
					{
						utc = 0; err = 2; break;	/* Failed to start logging */
					}
					beep(50, 2);		/* Two beeps. Start logging. */
				}
			} else {
				gp_rmctime(Line);
				f_write(&File1, Line, len, &bw);
				if (bw != len) {
					err = 3; break;
				}
				if (FLAGS & F_SYNC) {
					if (f_sync(&File1)) {
						err = 2; break;
					}
					FLAGS &= ~F_SYNC;
				}
			}
		}

		/* Stop GPS receiver */
		uart_deinit();
		GPS_OFF();
		FLAGS &= ~F_POW;

		/* Close file */
		if (utc && f_close(&File1)) err = 2;
		disk_ioctl(0, CTRL_POWER_OFF, 0);
		if (!err) beep(500, 1);	/* Long beep on file close succeeded */
	}

}


